<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>UCB CS188:Pacman Agent(1)</title>
    <link href="/2025/09/21/UCB-CS188-Pacman-Agent-1/"/>
    <url>/2025/09/21/UCB-CS188-Pacman-Agent-1/</url>
    
    <content type="html"><![CDATA[<h1 id="探索基础搜索算法：DFS、BFS与UCS"><a href="#探索基础搜索算法：DFS、BFS与UCS" class="headerlink" title="探索基础搜索算法：DFS、BFS与UCS"></a>探索基础搜索算法：DFS、BFS与UCS</h1><p>在人工智能和计算机科学领域，搜索算法是解决许多问题的核心工具。本文将深入探讨三种经典搜索算法：深度优先搜索（DFS）、广度优先搜索（BFS）和均匀成本搜索（UCS），并结合具体的Python代码实现来分析它们的工作原理和适用场景。</p><h2 id="1-算法原理概述"><a href="#1-算法原理概述" class="headerlink" title="1 算法原理概述"></a>1 算法原理概述</h2><h3 id="1-1-深度优先搜索（DFS）"><a href="#1-1-深度优先搜索（DFS）" class="headerlink" title="1.1 深度优先搜索（DFS）"></a>1.1 深度优先搜索（DFS）</h3><p>深度优先搜索采用<strong>后进先出（LIFO）<strong>的策略，优先探索分支的最深处。它使用</strong>栈（Stack）</strong> 结构来存储待探索的节点，适合寻找任意解或拓扑排序。</p><h3 id="1-2-广度优先搜索（BFS）"><a href="#1-2-广度优先搜索（BFS）" class="headerlink" title="1.2 广度优先搜索（BFS）"></a>1.2 广度优先搜索（BFS）</h3><p>广度优先搜索采用<strong>先进先出（FIFO）<strong>的策略，按层次逐步扩展搜索。它使用</strong>队列（Queue）</strong> 结构来存储待探索的节点，能确保找到最短路径（在无权图中）。</p><h3 id="1-3-均匀成本搜索（UCS）"><a href="#1-3-均匀成本搜索（UCS）" class="headerlink" title="1.3 均匀成本搜索（UCS）"></a>1.3 均匀成本搜索（UCS）</h3><p>均匀成本搜索是BFS的推广，用于<strong>加权图</strong>。它优先扩展当前路径成本最低的节点，使用<strong>优先队列（Priority Queue）</strong> 结构，确保找到成本最低的路径。</p><h2 id="2-代码实现分析"><a href="#2-代码实现分析" class="headerlink" title="2 代码实现分析"></a>2 代码实现分析</h2><p>以下代码实现了上述三种搜索算法，均采用图搜索方式（避免重复访问节点）。</p><h3 id="2-1-深度优先搜索（DFS）实现"><a href="#2-1-深度优先搜索（DFS）实现" class="headerlink" title="2.1 深度优先搜索（DFS）实现"></a>2.1 深度优先搜索（DFS）实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">depthFirstSearch</span>(<span class="hljs-params">problem: SearchProblem</span>) -&gt; <span class="hljs-type">List</span>[Directions]:<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Search the deepest nodes in the search tree first.</span><br><span class="hljs-string">    Your search algorithm needs to return a list of actions that reaches the goal. </span><br><span class="hljs-string">    Make sure to implement a graph search algorithm.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    frontier = util.Stack()  <span class="hljs-comment"># 使用栈实现DFS</span><br>    searched = <span class="hljs-built_in">set</span>()         <span class="hljs-comment"># 记录已访问节点，避免重复</span><br>    <span class="hljs-comment"># 初始状态：起点、空动作序列、初始成本0</span><br>    frontier.push((problem.getStartState(), [], <span class="hljs-number">0</span>))<br><br>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> frontier.isEmpty():<br>        state, actions, cost = frontier.pop()<br>        <br>        <span class="hljs-keyword">if</span> problem.isGoalState(state):  <span class="hljs-comment"># 目标测试</span><br>            <span class="hljs-keyword">return</span> actions<br>            <br>        <span class="hljs-keyword">if</span> state <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> searched:        <span class="hljs-comment"># 仅处理未访问节点</span><br>            searched.add(state)<br>            successors = problem.getSuccessors(state)<br>            <span class="hljs-keyword">for</span> next_state, action, step_cost <span class="hljs-keyword">in</span> successors:<br>                <span class="hljs-keyword">if</span> next_state <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> searched:  <span class="hljs-comment"># 图搜索：忽略已访问节点</span><br>                    <span class="hljs-comment"># 新动作序列 = 当前动作序列 + 新动作</span><br>                    new_actions = actions + [action]<br>                    new_cost = cost + step_cost<br>                    frontier.push((next_state, new_actions, new_cost))<br>                    <br>    <span class="hljs-keyword">return</span> []  <span class="hljs-comment"># 未找到路径时返回空列表</span><br></code></pre></td></tr></table></figure><p><strong>关键点</strong>：</p><ul><li><strong>数据结构</strong>：使用<code>util.Stack()</code>（栈），后进先出（LIFO）。</li><li><strong>状态记录</strong>：<code>searched</code>集合记录已扩展节点，避免重复访问和循环（图搜索）。</li><li><strong>路径记录</strong>：在节点中存储<code>actions</code>列表，记录从起点到当前节点的动作序列。</li><li><strong>扩展规则</strong>：对于每个节点的后继节点，若未访问，则计算新路径的成本和动作序列，并压入栈中。</li></ul><h3 id="2-2-广度优先搜索（BFS）实现"><a href="#2-2-广度优先搜索（BFS）实现" class="headerlink" title="2.2 广度优先搜索（BFS）实现"></a>2.2 广度优先搜索（BFS）实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">breadthFirstSearch</span>(<span class="hljs-params">problem: SearchProblem</span>) -&gt; <span class="hljs-type">List</span>[Directions]:<br>    <span class="hljs-string">&quot;&quot;&quot;Search the shallowest nodes in the search tree first.&quot;&quot;&quot;</span><br>    frontier = util.Queue()  <span class="hljs-comment"># 使用队列实现BFS</span><br>    searched = <span class="hljs-built_in">set</span>()<br>    frontier.push((problem.getStartState(), [], <span class="hljs-number">0</span>))<br><br>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> frontier.isEmpty():<br>        state, actions, cost = frontier.pop()<br>        <br>        <span class="hljs-keyword">if</span> problem.isGoalState(state):<br>            <span class="hljs-keyword">return</span> actions<br>            <br>        <span class="hljs-keyword">if</span> state <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> searched:<br>            searched.add(state)<br>            successors = problem.getSuccessors(state)<br>            <span class="hljs-keyword">for</span> next_state, action, step_cost <span class="hljs-keyword">in</span> successors:<br>                <span class="hljs-keyword">if</span> next_state <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> searched:<br>                    new_actions = actions + [action]<br>                    new_cost = cost + step_cost<br>                    frontier.push((next_state, new_actions, new_cost))<br>                    <br>    <span class="hljs-keyword">return</span> []<br></code></pre></td></tr></table></figure><p><strong>关键点</strong>：</p><ul><li><strong>数据结构</strong>：使用<code>util.Queue()</code>（队列），先进先出（FIFO）。</li><li><strong>完备性与最优性</strong>：在无权图中，BFS是完备的，且总能找到最短路径（最少步数）。</li><li><strong>扩展顺序</strong>：先扩展深度最浅的节点，确保按层次遍历。</li></ul><h3 id="2-3-均匀成本搜索（UCS）实现"><a href="#2-3-均匀成本搜索（UCS）实现" class="headerlink" title="2.3 均匀成本搜索（UCS）实现"></a>2.3 均匀成本搜索（UCS）实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">uniformCostSearch</span>(<span class="hljs-params">problem: SearchProblem</span>) -&gt; <span class="hljs-type">List</span>[Directions]:<br>    <span class="hljs-string">&quot;&quot;&quot;Search the node of least total cost first.&quot;&quot;&quot;</span><br>    frontier = util.PriorityQueue()  <span class="hljs-comment"># 使用优先队列实现UCS</span><br>    searched = <span class="hljs-built_in">set</span>()<br>    <span class="hljs-comment"># 初始状态按成本0优先级入队</span><br>    frontier.push((problem.getStartState(), [], <span class="hljs-number">0</span>), <span class="hljs-number">0</span>)<br><br>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> frontier.isEmpty():<br>        state, actions, cost = frontier.pop()<br>        <br>        <span class="hljs-keyword">if</span> problem.isGoalState(state):<br>            <span class="hljs-keyword">return</span> actions<br>            <br>        <span class="hljs-keyword">if</span> state <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> searched:<br>            searched.add(state)<br>            successors = problem.getSuccessors(state)<br>            <span class="hljs-keyword">for</span> next_state, action, step_cost <span class="hljs-keyword">in</span> successors:<br>                <span class="hljs-keyword">if</span> next_state <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> searched:<br>                    new_actions = actions + [action]<br>                    new_cost = cost + step_cost  <span class="hljs-comment"># 累计成本</span><br>                    <span class="hljs-comment"># 以新成本作为优先级入队</span><br>                    frontier.push((next_state, new_actions, new_cost), new_cost)<br>                    <br>    <span class="hljs-keyword">return</span> []<br></code></pre></td></tr></table></figure><p><strong>关键点</strong>：</p><ul><li><strong>数据结构</strong>：使用<code>util.PriorityQueue()</code>（优先队列），按路径成本排序。</li><li><strong>成本敏感</strong>：每次扩展累计成本<code>new_cost</code>最低的节点，确保找到成本最低的路径。</li><li><strong>最优性</strong>：在有权图中，UCS是完备的，且总能找到成本最低的路径（当成本非负时）。</li></ul><h2 id="3-三种算法的对比与应用"><a href="#3-三种算法的对比与应用" class="headerlink" title="3 三种算法的对比与应用"></a>3 三种算法的对比与应用</h2><p>为了更直观地比较这三种算法，以下是它们在数据结构、扩展顺序、最优性等方面的差异：</p><table><thead><tr><th align="left"><strong>特征</strong></th><th align="left"><strong>深度优先搜索（DFS）</strong></th><th align="left"><strong>广度优先搜索（BFS）</strong></th><th align="left"><strong>均匀成本搜索（UCS）</strong></th></tr></thead><tbody><tr><td align="left"><strong>数据结构</strong></td><td align="left">栈（Stack）</td><td align="left">队列（Queue）</td><td align="left">优先队列（Priority Queue）</td></tr><tr><td align="left"><strong>扩展顺序</strong></td><td align="left">最深节点</td><td align="left">最浅节点</td><td align="left">最小成本节点</td></tr><tr><td align="left"><strong>最优性</strong></td><td align="left">否（可能找到非最短路径）</td><td align="left">是（无权图最短路径）</td><td align="left">是（加权图最低成本路径）</td></tr><tr><td align="left"><strong>完备性</strong></td><td align="left">是（有限图）</td><td align="left">是（有限图）</td><td align="left">是（有限图，成本≥0）</td></tr><tr><td align="left"><strong>空间复杂度</strong></td><td align="left">O(bm)</td><td align="left">O(b^d)</td><td align="left">O(b^d)</td></tr><tr><td align="left"><strong>时间复杂度</strong></td><td align="left">O(b^m)</td><td align="left">O(b^d)</td><td align="left">O(b^d)</td></tr></tbody></table><blockquote><p><strong>符号说明</strong>：b为分支因子，d为解所在深度，m为最大深度。</p></blockquote><h3 id="3-1-实际应用场景"><a href="#3-1-实际应用场景" class="headerlink" title="3.1 实际应用场景"></a>3.1 实际应用场景</h3><ul><li><strong>DFS</strong>：适用于解空间较深、需快速找到一个可行解的场景，如迷宫求解、拓扑排序。</li><li><strong>BFS</strong>：适用于寻找最短路径（步数），如社交网络中的最短关系链、迷宫的最短出口路径。</li><li><strong>UCS</strong>：适用于考虑行动成本的场景，如地图导航中的最短行驶时间、资源消耗最小化。</li></ul><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>深度优先搜索、广度优先搜索和均匀成本搜索是图搜索中最基础的算法。它们通过不同的数据结构和控制策略，实现了各自优势的搜索策略。在实际应用中，根据问题需求（如是否需要最优解、解的空间特征、是否有权重等）选择合适的算法至关重要。理解这些算法的原理和实现，是构建更复杂人工智能系统（如A*搜索、蒙特卡洛树搜索等）的坚实基础。</p><blockquote><p><strong>提示</strong>：以上代码均基于图搜索（避免重复访问），若采用树搜索（允许重复访问），需移除<code>searched</code>集合的相关操作，但可能陷入循环。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Class</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Agent</tag>
      
      <tag>Search</tag>
      
      <tag>Algorithm</tag>
      
      <tag>CS188</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Blog Reading:LLM Powered Autonomous Agents -Lilian Weng</title>
    <link href="/2025/09/20/Blog-Reading-LLM-Powered-Autonomous-Agents-Lilian-Weng/"/>
    <url>/2025/09/20/Blog-Reading-LLM-Powered-Autonomous-Agents-Lilian-Weng/</url>
    
    <content type="html"><![CDATA[<p>该博文深入探讨了以<strong>大型语言模型（LLM）为核心控制器</strong>来构建<strong>自主智能代理（Autonomous Agents）</strong> 的概念、架构、组件、案例研究及其面临的挑战。文章指出，LLM的潜力远不止于生成文本，更可被视为一个强大的通用问题解决器，作为代理的“大脑”。</p><h3 id="核心架构概述"><a href="#核心架构概述" class="headerlink" title="核心架构概述"></a>核心架构概述</h3><p>一个LLM驱动的自主代理系统通常由三个关键组件协同工作：</p><ol><li><strong>规划（Planning）</strong>：代理的核心思维能力，用于分解任务和反思改进。</li><li><strong>记忆（Memory）</strong>：代理的存储系统，用于保留和召回信息。</li><li><strong>工具使用（Tool Use）</strong>：代理与外部世界交互的手段，扩展其内在能力。</li></ol><h3 id="组件一：规划-Planning"><a href="#组件一：规划-Planning" class="headerlink" title="组件一：规划 (Planning)"></a>组件一：规划 (Planning)</h3><p>规划使代理能够处理复杂任务，主要包括两个方面：</p><p><strong>1. 任务分解 (Task Decomposition)</strong></p><ul><li><strong>思维链（CoT）</strong>：标准技术，通过“一步一步思考”的提示，将复杂任务分解为更小、更简单的步骤。</li><li><strong>思维树（ToT）</strong>：CoT的扩展，在每一步探索多种推理可能性，形成树状结构，并通过广度优先搜索（BFS）或深度优先搜索（DFS）进行搜索，由分类器（通过提示）或多数投票评估状态。</li><li><strong>分解方法</strong>：可通过LLM简单提示、任务特定指令或人类输入完成。</li><li><strong>LLM+P</strong>：一种独特方法，将长期规划外包给<strong>外部经典规划器</strong>。LLM负责将问题转换为规划域定义语言（PDDL）， classical planner生成计划，LLM再将计划转换回自然语言。该方法依赖于现成的领域PDDL和规划器。</li></ul><p><strong>2. 自我反思 (Self-Reflection)</strong><br>自我反思使代理能够从错误中学习，迭代改进其行动和策略。</p><ul><li><strong>ReAct（Reason + Act）</strong>：将<strong>推理</strong>（生成自然语言思考轨迹）和<strong>行动</strong>（调用特定任务API）结合在一个框架内。其提示模板格式为：<code>Thought: ... Action: ... Observation: ...</code>。研究表明，ReAct在知识密集和决策任务上均优于仅行动的基线。</li><li><strong>Reflexion</strong>：一个为代理配备动态记忆和自我反思能力的框架，其灵感来自强化学习（RL）设置。它引入了一种<strong>启发式函数</strong>来检测低效规划或幻觉（连续相同动作导致相同观察），并决定何时停止当前轨迹并重置环境。通过<strong>少样本示例</strong>让LLM生成自我反思，并将这些反思存入工作记忆中以指导未来规划。</li><li>** hindsight（CoH）<strong>：通过向模型展示一个</strong>带有反馈的过去输出序列**（按奖励排序）进行监督微调，训练模型根据反馈历史趋势生成更好的输出。</li><li><strong>算法蒸馏（AD）</strong>：将CoH思想应用于强化学习。它将<strong>跨 episode 的学习历史</strong>串联起来作为模型的输入，目的是让模型学会<strong>强化学习过程本身</strong>，从而在上下文中表现出学习行为，其性能接近在线RL方法。</li></ul><h3 id="组件二：记忆-Memory"><a href="#组件二：记忆-Memory" class="headerlink" title="组件二：记忆 (Memory)"></a>组件二：记忆 (Memory)</h3><p>记忆使代理能够积累和利用过去的信息。</p><ul><li><strong>记忆类型</strong>（类比人类记忆）：<ul><li><strong>感官记忆</strong>：类比于对原始输入（文本、图像等）学习嵌入表示。</li><li><strong>短期记忆</strong>：类比于<strong>上下文学习</strong>。受Transformer上下文窗口长度限制，容量有限。</li><li><strong>长期记忆</strong>：类比于<strong>外部向量存储</strong>（Vector Store），通过快速检索访问，提供近乎无限的存储容量。</li></ul></li><li><strong>最大内积搜索（MIPS）</strong>：为了快速从向量库中检索信息，常使用<strong>近似最近邻（ANN）</strong> 算法。文章介绍了几种常见算法：<ul><li><strong>LSH</strong>（局部敏感哈希）</li><li><strong>ANNOY</strong>（基于随机投影树）</li><li><strong>HNSW</strong>（分层可导航小世界图）</li><li><strong>FAISS</strong>（基于向量量化）</li><li><strong>ScaNN</strong>（各向异性向量量化）</li></ul></li></ul><h3 id="组件三：工具使用-Tool-Use"><a href="#组件三：工具使用-Tool-Use" class="headerlink" title="组件三：工具使用 (Tool Use)"></a>组件三：工具使用 (Tool Use)</h3><p>工具使用极大地扩展了LLM的能力边界，使其能够获取实时信息、执行代码等。</p><ul><li><strong>MRKL</strong>：一种神经符号架构，LLM作为<strong>路由器</strong>，将问题路由到最适合的<strong>专家模块</strong>（可以是神经或符号工具，如计算器、API）。关键在于LLM能否可靠地决定<strong>何时</strong>及<strong>如何</strong>使用工具。</li><li><strong>TALM &amp; Toolformer</strong>：通过微调LLM来学习调用外部工具API。数据集通过判断添加API调用是否能改进输出质量来构建。</li><li><strong>实践案例</strong>：ChatGPT Plugins 和 OpenAI API function calling 是工具增强LLM的实际例子。</li><li><strong>HuggingGPT</strong>：一个框架，利用ChatGPT作为<strong>任务规划器</strong>，根据模型描述选择HuggingFace平台上的模型，并总结执行结果。其工作流程分为四个阶段：<ol><li><strong>任务规划</strong>：LLM解析用户请求为多个任务。</li><li><strong>模型选择</strong>：LLM将任务分配给专家模型。</li><li><strong>任务执行</strong>：专家模型执行任务。</li><li><strong>响应生成</strong>：LLM汇总结果返回给用户。</li></ol></li><li><strong>API-Bank</strong>：一个用于评估工具增强LLM性能的基准测试，包含53个API工具和264个对话。它在三个层次上评估代理：<ul><li><strong>Level-1</strong>：调用给定API的能力。</li><li><strong>Level-2</strong>：检索正确API的能力。</li><li><strong>Level-3</strong>：超越检索和调用的规划能力（处理模糊用户请求，需多次API调用）。</li></ul></li></ul><h3 id="案例研究-Case-Studies"><a href="#案例研究-Case-Studies" class="headerlink" title="案例研究 (Case Studies)"></a>案例研究 (Case Studies)</h3><ol><li><p><strong>科学发现代理</strong>：</p><ul><li><strong>ChemCrow</strong>：一个用于化学领域（有机合成、药物发现等）的代理，集成了13个专家设计的工具。使用ReAct和MRKL模式。<strong>关键发现</strong>：人类专家评估发现ChemCrow远优于GPT-4，突显了LLM在专业领域自我评估的局限性。</li><li><strong>Boiko et al.</strong>：探索LLM代理自主设计、规划和执行复杂科学实验，使用互联网浏览、文档阅读、代码执行、机器人实验API等工具。同时讨论了其用于合成化学武器等风险。</li></ul></li><li><p><strong>生成式代理模拟</strong>：</p><ul><li><strong>Generative Agents</strong>：一个有趣的实验，25个由LLM驱动的虚拟角色在一个沙盒环境中生活互动（类似《模拟人生》）。代理架构结合了：<ul><li><strong>记忆流</strong>：记录代理经验的外部数据库。</li><li><strong>检索模型</strong>：根据<strong>相关性、新近性和重要性</strong>从记忆流中检索信息。</li><li><strong>反思机制</strong>：将记忆合成为更高层次的推断，指导未来行为。</li><li><strong>规划与反应</strong>：将反射和环境信息转化为行动。</li></ul></li><li>结果涌现出信息传播、关系记忆和社交事件协调等<strong>逼真的社会行为</strong>。</li></ul></li><li><p><strong>概念验证示例</strong>：</p><ul><li><strong>AutoGPT</strong>：一个著名的PoC演示，展示了自主代理的潜力。其系统提示定义了目标、约束、可用命令（如谷歌搜索、读写文件、执行代码等），并要求以特定JSON格式响应。大量代码用于解析自然语言输出。</li><li><strong>GPT-Engineer</strong>：根据自然语言任务描述生成整个代码库。其工作流程包括：首先要求LLM<strong>澄清任务细节</strong>，然后进入<strong>代码生成模式</strong>（使用详细的系统提示，要求生成完整、可运行、跨文件兼容的代码）。</li></ul></li></ol><h3 id="挑战-Challenges"><a href="#挑战-Challenges" class="headerlink" title="挑战 (Challenges)"></a>挑战 (Challenges)</h3><p>文章最后指出了构建LLM驱动代理面临的主要挑战：</p><ol><li><strong>有限的上下文长度</strong>：限制了历史信息、详细指令和API上下文的包含。虽然向量存储提供了扩展，但其表示能力不如全注意力机制。</li><li><strong>长期规划与任务分解的困难</strong>：LLM在根据意外错误调整计划方面存在困难，其稳健性不如人类。</li><li><strong>自然语言接口的可靠性</strong>：LLM的输出可能存在格式错误或偶尔拒绝指令，导致系统需要大量代码来解析输出，可靠性成为问题。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这篇博文全面综述了LLM驱动自主代理的技术蓝图，将其分解为规划、记忆和使用工具三大核心模块，并辅以丰富的技术细节（如ReAct、Reflexion、HNSW、HuggingGPT等）和生动案例（ChemCrow, Generative Agents, AutoGPT）。最后，它客观地指出了当前技术在实际应用中面临的上下文限制、规划可靠性和接口稳定性等关键挑战，为读者提供了对该领域深入且系统的理解。</p>]]></content>
    
    
    <categories>
      
      <category>Blog Reading</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Agent</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络笔记</title>
    <link href="/2025/09/07/computer_network/"/>
    <url>/2025/09/07/computer_network/</url>
    
    <content type="html"><![CDATA[<h1 id="test"><a href="#test" class="headerlink" title="test"></a>test</h1><h2 id="test-test"><a href="#test-test" class="headerlink" title="test test"></a>test test</h2><h3 id="test-test-test"><a href="#test-test-test" class="headerlink" title="test test test"></a>test test test</h3><h3 id="another-test"><a href="#another-test" class="headerlink" title="another test"></a>another test</h3><h4 id="test-test-test-test"><a href="#test-test-test-test" class="headerlink" title="test test test test"></a>test test test test</h4>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Computer Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/09/07/hello-world/"/>
    <url>/2025/09/07/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
